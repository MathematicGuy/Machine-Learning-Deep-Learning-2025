[00:00:03] What I'd like to do today is continue our discussion of supervised learning.
[00:00:10] So last Wednesday, you saw the linear regression algorithm, uh, including both gradient descent, how to formulate the problem,
[00:00:19] then gradient descent, and then the normal equations. What I'd like to do today is, um,
[00:00:25] talk about locally weighted regression which is a, a way to modify linear regressions and make it
[00:00:30] fit very non-linear functions so you aren't just fitting straight lines. And then I'll talk about a probabilistic interpretation of linear regression and that will
[00:00:39] lead us into the first classification algorithm you see in this class called logistic regression,
[00:00:44] and we'll talk about an algorithm called Newton's method for logistic regression. And so the dependency of ideas in this class is that,
[00:00:52] um, locally weighted regression will depend on what you learned in linear regression.
[00:00:57] And then, um, we're actually gonna just cover the key ideas of locally weighted regression,
[00:01:03] and let you play with some of the ideas yourself in the, um, problem set 1 which we'll release later this week.
[00:01:08] And then, um, I guess, give a probabilistic interpretation of linear regression, logistic regression depend on that, um,
[00:01:15] and Newton's method is for logistic regression, okay? To recap the notation you saw on Wednesday,
[00:01:23] we use this notation x_i, i- y_i to denote a single training example where x_i was n + 1 dimensional.
[00:01:33] So if you have two features, the size of the house and the number of bedrooms, then x_i would be 2 + 1, it would 3-dimensional because we have introduced a new,
[00:01:43] uh, sort of fake feature x_0 which was always set to the value of 1. Uh, and then yi,
[00:01:49] in the case of regression is always a real number and what's the number of training examples and what's the number of features
[00:01:56] and, uh, this was the hypothesis, right? It's a linear function of the features x, um,
[00:02:02] including this feature x_0 which is always set to 1, and, uh, j was the cost function you would minimize,
[00:02:09] you minimize this as function of j to find the parameters Theta for your straight line fit to the data, okay?
[00:02:17] So that's what you saw last Wednesday. Um, now if you have a dataset, that looks like that,
[00:02:30] where this is the size of a house and this is the price of a house. What you saw on Wednesday- last Wednesday,
[00:02:38] was an algorithm to fit a straight line, right to this data so the hypothesis was of the form
[00:02:45] Theta 0 + Theta 1 x_0- x_0- Theta 1 x_1 to be very specific.
[00:02:50] But with this dataset maybe it actually looks, you know, maybe the data looks a little bit like that and so
[00:02:57] one question that you have to address when, uh, fitting models to data is what are the features you want?
[00:03:03] Do you want to fit a straight line to this problem or do you want to fit a hypothesis of the form, um,
[00:03:10] Theta 1x + Theta 2x squared since this may be a quadratic function, right?
[00:03:19] Now the problem with quadratic functions is that quadratic functions eventually start, you know, curving back down so that will be a quadratic function.
[00:03:25] This arc starts curving back down. So maybe you don't want to fit a quadratic function. Uh, instead maybe you want, uh, to fit something like that.
[00:03:37] If- if housing prices sort of curved down a little bit but you don't want it to eventually curve back down the way a quadratic function would, right?
[00:03:46] Um, so- oh, and, and if you want to do this the way you would implement is
[00:03:51] is you define the first feature x_1 = x and the second feature x_2 = x squared or you
[00:03:57] define x_1 to be equal to x and x_2 = square root of x, right and by defining a new feature x_2 which would be the square root of x and square root of x.
[00:04:06] Then the machinery that you saw from Wednesday of linear regression applies to fit these types of,
[00:04:12] um, these types of functions of the data. So later this quarter you'll hear about feature selection algorithms,
[00:04:20] which is a type of algorithm for automatically deciding, do you want x squared as a feature or
[00:04:25] square root of x as a feature or maybe you want, um, log of x as a feature, right.
[00:04:31] But what set of features, um, does the best job fitting the data that you have if it's not fit well by a perfectly straight line.
[00:04:39] Um, what I would like to do today is- so, so you'll hear about feature selection later this quarter.
[00:04:45] What I want to share with you today is a different way of addressing this out- this problem of whether the data isn't just fit well by
[00:04:52] a straight line and in particular I wanna share with you an idea called, uh, locally weighted regression or locally weighted linear regression.
[00:04:58] So let me use a slightly different, um, example to illustrate this.
[00:05:04] Um, which is, uh, which is that, you know, if you have a dataset that looks like that.
[00:05:09] [NOISE] So it's pretty clear what the shape of this data is.
[00:05:21] Um, but how do you fit a curve that, you know, kind of looks like that, right? And it's, it's actually quite difficult to find features, is it square root of x,
[00:05:29] log of x, x cube, like third root of x, x the power of 2/3. But what is the set of features that lets you do this? So
[00:05:35] we'll sidestep all those problems with an algorithm called, uh, locally weighted regression.
[00:05:53] Um, okay, and to introduce a bit more machine learning terminology.
[00:05:58] Um, in machine learning we sometimes distinguish between parametric learning algorithms and non-parametric learning algorithms.
[00:06:10] But in a parametric learning algorithm does, uh, uh, you fit some fixed set of parameters such as Theta
[00:06:23] i to data and so linear regression as you saw last Wednesday is a parametric learning algorithm
[00:06:31] because there's a fixed set of parameters, the Theta i's, so you fit to data and then you're done, right.
[00:06:36] Locally weighted regression will be our first exposure to a non-parametric learning algorithm.
[00:06:49] Um, and what that means is that the amount of data/parameters, uh,
[00:06:58] you need to keep grows and in
[00:07:07] this case it grows linearly with the size of the data,
[00:07:16] with size of training set, okay? So with the parametric learning algorithm, no matter how big your training, uh,
[00:07:23] your training set is, you fit the parameters Theta i. Then you could erase a training set from
[00:07:28] your computer memory and make predictions just using the parameters Theta i and in a non-parametric learning algorithm which we'll see in a second,
[00:07:35] the amount of stuff you need to keep around in computer memory or the amount of stuff you need to store around grows linearly as a function of the training set size.
[00:07:43] Uh, and so this type of algorithm is your- may, may, may not be great if you have a really, really massive dataset because you need to keep all of the data around
[00:07:51] your- in computer memory or on disk just to make predictions, okay? So- but we'll see an example of this
[00:07:57] and one of the effects of this is that with that, it'll, it'll be able to fit that data that I drew up there, uh,
[00:08:04] quite well without you needing to fiddle manually with features. Um, and again you get to practice implementing locally weighted regression in the homework.
[00:08:13] So I'm gonna go over the height of ideas relatively quickly and then let you, uh, uh, gain practice, uh, in the problem set. All right.
[00:08:22] So let me redraw that dataset, it'd be something like this. [NOISE] All right.
[00:08:30] So- so say you have a dataset like this. Um, now for linear regression if you want to evaluate
[00:08:41] h at a certain value of the input, right?
[00:08:52] So to make a prediction at a certain value of x what you- for linear regression what you do is you fit theta,
[00:09:03] you know, to minimize this cost function. [NOISE]
[00:09:16] And then you return Theta transpose x, right? So you fit a straight line and then, you know,
[00:09:23] if you want to make a prediction at this value x you then return say the transpose x.
[00:09:29] For locally weighted regression,
[00:09:39] um, you do something slightly different. Which is if this is the value of x
[00:09:46] and you want to make a prediction around that value of x. What you do is you look in a lo- local neighborhood
[00:09:52] at the training examples close to that point x where you want to make a prediction. And then, um, I'll describe this informally for now
[00:10:00] but we'll- we'll formalize this in math for the second. Um, but focusing mainly on these examples and,
[00:10:07] you know, looking a little bit at further all the examples. But really focusing mainly on these examples, you try to fit a straight line like that,
[00:10:15] focusing on the training examples that are close to where you want to make a prediction. And by close I mean the values are similar, uh, on the x axis.
[00:10:24] The x values are similar. And then to actually make a prediction, you will, uh,
[00:10:30] use this green line that you just fit to make a prediction at that value of x, okay?
[00:10:37] Now if you want to make a prediction at a different point. Um, let's say that, you know,
[00:10:43] the user now says, "Hey, make a prediction for this point." Then what you would do is you focus on this local area,
[00:10:50] kinda look at those points. Um, and when I say focus say, you know, put most of the weights on these points but you
[00:10:55] kinda take a glance at the points further away, but mostly the attention is on these for the straight line to that,
[00:11:01] and then you use that straight line to make a prediction, okay. Um, and so to formalize this in locally weighted regression, um,
[00:11:15] you will fit Theta to minimize a modified cost function
[00:11:21] [NOISE]
[00:11:34] Where wi is a weight function.
[00:11:43] Um, and so a good- well the default choice, a common choice for wi will be this.
[00:11:49] [NOISE] Right, um, I'm gonna add something to this equation a little bit later.
[00:11:59] But, uh, wi is a weighting function where, notice that this, this formula has a defining property, right?
[00:12:09] If xi - x is small, then the weight will be close to 1.
[00:12:19] Because, uh, if xi x- so x is the location where you want to make a prediction and xi is the input x for your ith training example.
[00:12:30] So wi is a weighting function, um, that's a value between 0 and 1 that tells you how much should you pay attention to
[00:12:39] the values of xi, yi when fitting say this green line or that red line.
[00:12:45] And so if xi - x is small
[00:12:51] so that's a training example that is close to where you want to make the prediction for x. Then this is about e to the 0, right,
[00:12:59] e to the -0 if the- if the numerator here is small and e to the 0 is close to 1.
[00:13:05] Right, um, and conversely if xi - x is large,
[00:13:13] then wi is close to 0. And so if xi is very far away so let's see if it's fitting this green line.
[00:13:22] And this is your example, xi yi then it's saying, give this
[00:13:28] example all the way out there if you're fitting the green line where you look at this first x saying that example should have weight fairly close to 0, okay?
[00:13:38] Um, and so if you, um, look at the cost function,
[00:13:46] the main modification to the cost function we've made is that we've added this weighting term, right?
[00:13:54] And so what locally weighted regression does is the same. If an example xi is far from where you wanna make
[00:14:02] a prediction multiply that error term by 0 or by a constant very close to 0.
[00:14:08] Um, whereas if it's close to where you wanna make a prediction multiply that error term by 1.
[00:14:14] And so the net effect of this is that this is summing if, if, you know, the terms multiplied by 0 disappear, right?
[00:14:21] So the net effect of this is that the sums over essentially only the terms, uh,
[00:14:27] for the squared error for the examples that are close to the value, close to the value of x where you want to make a prediction, okay?
[00:14:36] Um, and that's why when you fit Theta to minimize this,
[00:14:45] you end up paying attention only to the points, only to the examples close to where you wanna make a prediction and
[00:14:51] fitting a line like a green line over there, okay? Um, so let me draw a couple more pictures to- to- to illustrate this.
[00:15:00] Um, so if- let me draw a slightly smaller data set just to make this easier to illustrate.
[00:15:08] Um, so that's your training set. So there's your examples x1, x2, x3, x4. And if you want to make a prediction here, right,
[00:15:16] at that point x, then, um, this curve here looks the- the- the shape of this curve is actually like this, right?
[00:15:27] Um, and this is the shape of a Gaussian bell curve. But this has nothing to do with a Gaussian density,
[00:15:33] right, so this thing does not integrate to 1. So- so it's just sometimes you ask well, is this- is this using a Gaussian density? The answer is no.
[00:15:40] Uh, this is just a function that, um, is shaped a lot like a Gaussian but, you know,
[00:15:45] Gaussian densities, probability density functions have to integrate to 1 and this does not. So there's nothing to do with a Gaussian probability density. Question?
[00:15:52] So how- how do you choose the width of the- Oh, so how do you choose the width, lemmi get back to that.
[00:15:58] Yeah. Um, and so for this example this height
[00:16:04] here says give this example a weight equal to the height of that thing.
[00:16:09] Give this example a weight to the height of this, height of this, height of that, right?
[00:16:15] Which is why if you actually- if you have an example this way out there, you know, is given a weight that's essentially 0.
[00:16:22] Which is why it's weighting only the nearby examples when trying to fit a straight line, right, uh, for the- for making predictions close to this, okay?
[00:16:33] Um, now so one last thing that I wanna mention which is,
[00:16:40] um, the- the- the question just now which is how do you choose the width of this Gaussian density, right?
[00:16:46] How fat it is or how thin should it be? Um, and this decides how big a neighborhood should you look in
[00:16:52] order to decide what's the neighborhood of points you should use to fit this, you know, local straight line.
[00:16:57] And so, um, for Gaussian function like this, uh, this- I'm gonna call this the, um, bandwidth parameter tau, right?
[00:17:11] And this is a parameter or a hyper-parameter of the algorithm.
[00:17:17] And, uh, depending on the choice of tau, um, uh, you can choose a fatter or a thinner bell-shaped curve,
[00:17:24] which causes you to look in a bigger or a narrower window in order to decide,
[00:17:30] um, you know, how many nearby examples to use in order to fit the straight line, okay?
[00:17:36] And it turns out that, um, and I wanna leave- I wanna leave you to discover this yourself in the problem set.
[00:17:41] Um, if- if you've taken a little bit of machine learning elsewhere I've heard of the terms [inaudible] Test. It's on?
[00:17:52] Okay, good. It was on. Good. It turns out that, um, the choice of the bandwidth tau has an effect on,
[00:17:58] uh, overfitting and underfitting. If you don't know what those terms mean don't worry about it, we'll define them later in this course. But, uh, what you get to do in the problem set is, uh,
[00:18:07] play with tau yourself and see why, um, if tau is too broad, you end up fitting, um,
[00:18:16] you end up over-smoothing the data and if tau is too thin you end up fitting a very jagged fit to the data.
[00:18:21] And if any of these things don't make sense yet don't worry about it they'll make sense after you play a bit in the- in the problem set, okay?
[00:18:28] Um, so yeah, since- since you- you play with the varying tau in the problem set and see for yourself the net impact of that, okay? Question?
[00:18:38] Is tau raised to power there or is that just a- just a- [NOISE] Thank you, uh, this is tau squared.
[00:18:44] Yeah. Yeah.
[00:18:53] So- so what happens if you need to invert, uh, the [inaudible] What happens if you need to infer the value of h outside the scope of the dataset?
[00:18:59] It turns out that you can still use this algorithm. It's just that, um, its results may not be very good.
[00:19:06] Yeah. It- it- it depends I guess. Um, locally linear regression is usually not greater than extrapolation,
[00:19:14] but then most- many learning algorithms are not good at extrapolation. So all- all the formulas still work, you can still implement this.
[00:19:20] But, um, yeah. You can also try- you can also try a linear problem set and see what happens. Yeah. One last question.
[00:19:26] Is it possible to have like a vertical tau depending on whether some parts of your data have lots of- Yeah.
[00:19:34] Yes, this is mostly for the variable tau depending- Uh, uh, yes, it is, uh, and there are quite complicated ways to choose
[00:19:41] tau based on how many points there on the local region and so on. Yes. There's a huge literature on different formulas actually for example
[00:19:47] instead of this Gaussian bump thing, uh, there's, uh, sometimes people use that triangle shape function.
[00:19:53] So it actually goes to zero outside some small rings. So there are, there are many versions of this algorithm.
[00:19:58] Um, so I tend to use, uh, a locally weighted linear regression when,
[00:20:03] uh, you have a relatively low dimensional data set. So when the number of features is not too big, right?
[00:20:09] So when n is quite small like 2 or 3 or something and we have a lot of data. And you don't wanna think about what features to use, right.
[00:20:16] So- so that's the scenario. So if, if you actually have a data set that looks like these up in drawing, you know,
[00:20:22] locally weighted linear regression is, is a, is a pretty good algorithm. Um, just one last question. Then we're moving on.
[00:20:29] When you have a lot of data like this, does it usually complicate the question, since you're [BACKGROUND]
[00:20:35] Oh, sure. Yes, if you have a lot of data, that wants to be computationally expensive, yes, it would be. Uh, I guess a lot of data is relative.
[00:20:42] Uh, yes we have, you know, 2, 3, 4 dimensional data and hundreds of examples, I mean, thousands of examples.
[00:20:48] Uh, it turns out the computation needed to fit the minimization is, uh, similar to the normal equations,
[00:20:54] and so you- it involves solving a linear system of equations of dimension equal to the number of training examples you have.
[00:21:00] So, if that's, you know, like a thousand or a few thousands, that's not too bad. If you have millions of examples then,
[00:21:06] then there are also multiple scaling algorithms like KD trees and much more complicated algorithms to do this when you
[00:21:11] have millions or hun- tens of millions of examples. Yeah. Okay. So you get a better sense of this algorithm when you play with it,
[00:21:21] um, in the problem set. Now, the second topic-one of- so I'm gonna put aside locally weighted regression.
[00:21:29] We won't talk about that set of ideas anymore, uh, today. But, but what I wanna do today is, uh,
[00:21:35] on last Wednesday I had said that- I had promised last Wednesday that today I'll give a justification for why we use the squared error, right.
[00:21:44] Why the squared error and why not to the fourth power or absolute value? Um, and so, um, what I want to show you today- now is
[00:21:53] a probabilistic interpretation of linear regression and this probabilistic interpretation will put us in good standing as we go on to logistic regression today,
[00:22:01] uh, and then generalize linear models later this week. We're going to keep up to-keep the notation there so we could continue to refer to it.
[00:22:24] So why these squares? Why squared error? Um, I'm gonna present a set of assumptions
[00:22:30] under which these squares using squared error falls out very naturally. Which is let's say for housing price prediction.
[00:22:38] Let's assume that there's a true price of every house y i which is x transpose,
[00:22:47] um, say there i, plus epsilon i.
[00:22:52] Where epsilon i is an error term. That includes, um, unmodeled effects,
[00:23:04] you know, and just random noise.
[00:23:09] Okay. So let's assume that the way, you know, housing prices truly work is that every house's price
[00:23:16] is a linear function of the size of the house and number of bedrooms, plus an error term that captures unmodeled effects such as maybe one day
[00:23:25] that seller is in an unusually good mood or an unusually bad mood and so that makes the price go higher or lower.
[00:23:30] We just don't model that, um, as well as random noise, right. Or, or maybe the model will skew this street, you know,
[00:23:37] preset to persistent capture, that's one of the features, but other things have an impact on housing prices.
[00:23:42] Um, and we're going to assume that, uh,
[00:23:48] epsilon i is distributed Gaussian would mean 0 and co-variance sigma squared.
[00:23:56] So I'm going to use this notation to mean- so the way you read this notation is epsilon i this twiddle you pronounce as, it's distributed.
[00:24:05] And then stripped n parens 0, sigma squared. This is a normal distribution also called the Gaussian Distribution, same thing.
[00:24:12] Normal distribution and Gaussian distribution mean the same thing. The normal distribution would mean 0 and,
[00:24:18] um, a variance sigma squared. Okay. Um, and what this means is that the probability density of epsilon i is- this is
[00:24:27] the Gaussian density, 1 over root 2 pi sigma e to the negative epsilon i squared over 2 sigma squared.
[00:24:36] Okay. And unlike the Bell state-the bell-shaped curve I used earlier for locally weighted linear regression,
[00:24:42] this thing does integrate to 1, right. This-this function integrates to 1. Uh, and so this is a Gaussian density,
[00:24:49] this is a prob-prob-probability density function. Um, and this is the familiar, you know,
[00:24:57] Gaussian bell-shaped curve with mean 0 and co-variance- and variance,
[00:25:03] uh, uh, sigma squared where sigma kinda controls the width of this Gaussian.
[00:25:09] Okay? Uh, and if you haven't seen Gaussian's for a while we'll go over some of the, er, probability, probability pre-reqs as well in the classes, Friday discussion sections.
[00:25:23] So, in other words, um, we assume that the way housing prices are determined is that,
[00:25:28] first is a true price theta transpose x. And then, you know, some random force of nature.
[00:25:34] Right, the mood of the seller or, I-I-I don't know-I don't have other factors, right.
[00:25:40] Perturbs it from this true value, theta transpose xi. Um, and the huge assumption we're gonna make is that the epsilon I's
[00:25:49] these error terms are IID. And IID from statistics stands for Independently and Identically Distributed.
[00:25:56] And what that means is that the error term for one house is independent, uh, as the error term for a different house.
[00:26:03] Which is actually not a true assumption. Right. Because, you know, if, if one house is priced on one street is
[00:26:08] unusually high, probably a price on a different house on the same street will also be unusually high. And so- but, uh, this assumption that these epsilon I's are
[00:26:17] IID since they're independently and identically distributed. Um, is one of those assumptions that,
[00:26:22] that, you know, is probably not absolutely true, but may be good enough that if you make this assumption, you get a pretty good model.
[00:26:28] Okay. Um, and so let's see. Under these set of assumptions this implies that [NOISE] the density or
[00:26:44] the probability of y i given x i and theta this is going to be this.
[00:27:03] Um, and I'll, I'll take this and write it in another way.
[00:27:21] In other words, given x and theta, what's the density- what's the probability of a particular house's price?
[00:27:31] Well, it's going to be Gaussian with mean given by theta transpose xi or theta transpose x,
[00:27:37] and the variance is, um, given by sigma squared. Okay. Um, and so, uh,
[00:27:45] because the way that the price of a house is determined is by taking theta transpose x with the, you know,
[00:27:51] quote true price of the house and then adding noise or adding error of variance sigma squared to it.
[00:27:57] And so, um, the, the assumptions on the left imply that given x and theta,
[00:28:02] the density of y, you know, has this distribution. Which is- really this is the random variable y,
[00:28:09] and that's the mean, right, and that's the variance of the Gaussian density.
[00:28:16] Okay. Now, um, two pieces of notation. Um, I want to, one that you should get familiar with.
[00:28:25] Um, the reason I wrote the semicolon here is, uh, that- the way you read this equation is the semicolon should be read as parameterized as.
[00:28:37] Right, um, and so because, uh, uh, the,
[00:28:43] the alternative way to write this would be to say P of xi given yi, excuse me, P of y given xi comma theta.
[00:28:51] But if you were to write this notation this way, this would be conditioning on theta,
[00:28:56] but theta is not a random variable. So you shouldn't condition on theta, which is why I'm gonna write a semicolon.
[00:29:03] And so the way you read this is, the probability of yi given xi and parameterize, oh, excuse me, parameterized by theta is equal to that formula, okay?
[00:29:13] Um, if, if, if you don't understand this distinction, again, don't worry too much about it. In, in statistics there are multiple schools of statistics called Bayesian statistics,
[00:29:22] frequentist statistics, this is a frequentist interpretation. Uh, for the purposes of machine learning, don't worry about it,
[00:29:27] but I find that being more consistent with terminology prevents some of our statistician friends from getting really upset, but, but,
[00:29:33] but, you know, I'll try to follow statistics convention. Uh, so- because just only unnecessary flack I guess,
[00:29:41] um, but for the per- for practical purposes this is not that important. If you forget this notation on your homework. don't worry about it we won't penalize you,
[00:29:47] but I'll try to be consistent. Um, but this just means that theta in this view is not a random variable,
[00:29:53] it's just theta is a set of parameters that parameterizes this probability distribution. Okay? Um, and the way to read the second equation is, um,
[00:30:03] when you write these equations usually don't write them with parentheses, but the way to parse this equation is to say that this thing is a random variable.
[00:30:11] The random variable y given x and parameterized by theta. This thing that I just drew in
[00:30:17] green parentheses is just a distributed Gaussian with that distribution, okay? All right. Um, any questions about this?
[00:30:31] Okay. So it turns out that
[00:30:37] [NOISE] if you are willing to make those assumptions,
[00:30:45] then linear regression, um, falls out almost naturally of the assumptions we just made.
[00:30:57] And in particular, under the assumptions we just made, um,
[00:31:02] the likelihood of the parameters theta,
[00:31:09] so this is pronounced the likelihood of the parameters theta,
[00:31:17] uh, L of theta which is defined as the probability of the data.
[00:31:24] Right? So this is probability of all the values of y of y1 up to ym given all the xs and given,
[00:31:31] uh, the parameters theta parameterized by theta. Um, this is equal to the product from I equals
[00:31:42] 1 through m of p of yi given xi parameterized by theta.
[00:31:53] Um, because we assumed the examples were- because we assume the errors are IID, right,
[00:31:59] that the error terms are independently and identically distributed to each other, so the probability of all of the observations,
[00:32:06] of all the values of y in your training set is equal to the product of the probabilities, because of the independence assumption we made.
[00:32:12] And so plugging in the definition of p of y given x parameterized by theta that we had up there,
[00:32:18] this is equal to product of that.
[00:32:36] Okay? Now, um, again, one more piece of terminology.
[00:32:44] Uh, you know, another question I've always been asked if you say, hey, Andrew, what's the difference between likelihood and probability, right?
[00:32:51] And so the likelihood of the parameters is exactly the same thing as the probability of the data,
[00:32:56] uh, but the reason we sometimes talk about likelihood, and sometimes talk of probability is, um, we think of likelihood.
[00:33:03] So this, this is some function, right? This thing is a function of the data as well as a function of the parameters theta.
[00:33:09] And if you view this number, whatever this number is, if you view this thing as a function of the parameters holding the data fixed,
[00:33:16] then we call that the likelihood. So if you think of the training set the data as a fixed thing, and then varying parameters theta,
[00:33:23] then I'm going to use the term likelihood. Whereas if you view the parameters theta as fixed and maybe varying the data,
[00:33:30] I'm gonna say probability, right? So, so you hear me use- well, I'll, I'll try to be consistent.
[00:33:35] I find I'm, I'm pretty good at being consistent but not perfect, but I'm going to try to say likelihood of the parameters,
[00:33:42] and probability of the data even though those evaluate to the same thing as just, you know,
[00:33:47] for this function, this function is a function of theta and the parameters which one are you viewing as fixed and which one are you viewing as, as variables.
[00:33:53] So when you view this as a function of theta, I'm gonna use this term likelihood. Uh, but- so, so hopefully you hear me say likelihood of the parameters.
[00:34:02] Hopefully you won't hear me say likelihood of the data, right? And, and similarly, hopefully you hear me say probability of
[00:34:08] the data and not the probability of the parameters, okay? Yeah. [inaudible].
[00:34:19] Like other parameters. [inaudible]. Uh, okay.
[00:34:25] So probability of the data. No. Uh, uh, theta, I got it sorry, yes.
[00:34:32] Likelihood of theta. Got it. Yes. Sorry. Yes. Likelihood of theta. That's right.
[00:34:44] [inaudible]. Oh, uh, no. So- no. Uh, uh, so theta is a set of parameters, it's not a random variable.
[00:34:50] So we- likelihood of theta doesn't mean theta is a random variable. Right. Cool. Yeah. Thank you.
[00:34:56] Um, by the way, the, the, the stuff about what's a random variable and what's not, the semicolon versus comma thing.
[00:35:01] We explained this in more detail in the lecture notes. To me this is part of, um, uh, you know,
[00:35:07] a little bit paying homage to the- to the religion of Bayesian frequencies versus Bayesian,
[00:35:14] uh, frequentist versus Bayesians in statistics. From a- from a machine- from an applied machine learning
[00:35:19] operational what you write code point of view, it doesn't matter that much. Uh, yeah. But theta is not a random variable,
[00:35:26] we have likelihood of parameters which are not a variable. Yeah. Go ahead. [inaudible]. Oh, what's the rationale for choosing,
[00:35:37] uh, oh, sure, why is epsilon i Gaussian? So, uh, uh, turns out because of central limit theorem,
[00:35:45] uh, from statistics, uh, most error distributions are Gaussian, right? If something is- if there's an era that's made up of
[00:35:52] lots of little noise sources which are not too correlated, then by central limit theorem it will be Gaussian.
[00:35:57] So if you think that, most perturbations are, the mood of the seller, what's the school district, you know,
[00:36:02] what's the weather like, or access to transportation, and all of these sources are not too correlated, and you add them up then the distribution will be Gaussian.
[00:36:09] Um, and, and I think- well, yeah. So you can use the central limit theorem,
[00:36:15] I think the Gaussian has become a default noise distribution. But for things where the true noise distribution is very far from Gaussian,
[00:36:23] uh, this model does do that as well. And in fact, for when you see generalized linear models on Wednesday,
[00:36:29] you see when- how to generalize all of these algorithms to very different distributions like Poisson, and so on.
[00:36:36] All right. So, um, so we've seen the likelihood of the parameters theta.
[00:36:45] Um, so I'm gonna use lower case l to denote the log-likelihood.
[00:36:55] And the log-likelihood is just the log of the likelihood. Um, and so- well, just- right.
[00:37:10] And so, um, log of a product is equal to the sum of the logs.
[00:37:15] Uh, and so this is equal to-
[00:37:31] and so this is m log 1 over root.
[00:37:49] Okay? Um. And so, um, one of the, uh, you know,
[00:37:58] well-tested letters in statistics estimating parameters is to use maximum likelihood estimation or MLE
[00:38:20] which means you choose theta
[00:38:26] to maximize the likelihood, right?
[00:38:33] So given the data set, how would you like to estimate theta?
[00:38:38] Well, one natural way to choose theta is to choose whatever value of theta has a highest likelihood.
[00:38:44] Or in other words, choose a value of theta so that that value of theta maximizes the probability of the data, right?
[00:38:51] And so, um, for- to simplify the algebra rather than
[00:38:57] maximizing the likelihood capital L is actually easier to maximize the log likelihood.
[00:39:02] But the log is a strictly monotonically increasing function. So the value of theta that maximizes
[00:39:07] the log likelihood should be the same as the value of theta that maximizes the likelihood. And if you divide the log likelihood, um,
[00:39:15] we conclude that if you're using maximum likelihood estimation, what you'd like to do is choose a value of theta that maximizes this thing, right?
[00:39:23] But, uh, this first term is just a constant, theta doesn't even appear in this first term.
[00:39:29] And so what you'd like to do is choose the value of theta that maximizes this second term.
[00:39:35] Ah, notice there's a minus sign there. And so what you'd like to do is,
[00:39:41] uh, uh, i.e, you know, choose theta to minimize this term.
[00:40:01] Right. Also, sigma squared is just a constant. Right. No matter what sigma squared is,
[00:40:07] you know, so, so, uh, so if you want to minimize this term, excuse me, if you want to maximize this term,
[00:40:13] negative of this thing, that's the same as minimizing this term. Uh, but this is just J of theta.
[00:40:22] The cost function you saw earlier for linear regression. Okay? So this little proof shows that,
[00:40:30] um, choosing the value of theta to minimize the least squares errors,
[00:40:36] like you saw last Wednesday, that's just finding the maximum likelihood estimate
[00:40:41] for the parameters theta under this set of assumptions we made, that the error terms are Gaussian and IID.
[00:40:49] Okay, go ahead. Oh, thank you.
[00:40:54] Yes. Great. Thanks. Go ahead. [inaudible].
[00:41:07] Oh, is there a situation where using this formula instead of least squares cost function will be a good idea? No. So this- I think this derivation shows that
[00:41:14] this- this is completely equivalent to least squares. Right. That if- if you want- if you're willing
[00:41:19] to assume that the error terms are Gaussian and IID and if you want to use Maximum Likelihood Estimation which is a very natural procedure in statistics,
[00:41:28] then, you know, then you should use least squares. Right. So yeah.
[00:41:33] If you know for some reason that the errors are not IID, like, is there a better way to figure out a better cost function?
[00:41:43] If you know for some reason errors are not IID, could you figure out a better cost function? Yes and no. I think that, um, you know, when building learners algorithms,
[00:41:50] ah, often we make model- we make assumptions about the world that we just know are not 100% true because it leads to algorithms that are computationally efficient.
[00:41:58] Um, and so if you knew that your- if you knew that your training set was very very non IID,
[00:42:04] there are- there're more sophisticated models you could build. But, um, ah, ah, yeah.
[00:42:10] But- but very often we wouldn't bother I think. Yeah. More often than not we might not bother.
[00:42:16] Ah, I can think of a few special cases where you would bother there but only if you think the assumption is really really bad.
[00:42:22] Ah, if you don't have enough data or something- something. Quite- quite rare. All right. Um, lemme think why, all right.
[00:42:30] I want to move on to make sure we get through the rest of things. Any burning questions? Yeah, okay, cool.
[00:42:36] All right. Um, so out of this machinery.
[00:42:43] Right. So- so- so what did we do here? Was we set up a set of probabilistic assumptions,
[00:42:48] we made certain assumptions about P of Y given X, where the key assumption was Gaussian errors in IID.
[00:42:54] And then through maximum likelihood estimation, we derived an algorithm which turns out to be exactly the least squares algorithm.
[00:43:01] Right? Um, what I'd like to do is take this framework, ah, and apply it to our first classification problem.
[00:43:09] Right. And so the- the key steps are, you know, one, make an assumption about P of Y given X,
[00:43:15] P of Y given X parameters theta, and then second is figure out maximum likelihood estimation. So I'd like to take this framework and apply it to a different type of problem,
[00:43:22] where the value of Y is now either 0 or 1. So is a classification problem.
[00:43:28] Okay? So, um, let's see.
[00:43:39] So the classification problem. In our first classification problem,
[00:43:44] we're going to start with binary classification. So the value of Y is either 0 or 1.
[00:43:50] And sometimes we call this binary classification because there are two clauses.
[00:43:55] Classification. Right. Um, and so right- so that's
[00:44:08] a data set where I guess this is X and this is Y. Um, so something that's not a good idea is to apply linear regression to this data set.
[00:44:18] Some- sometimes you will do it and maybe you'll get away with it but I wouldn't do it and here's. Which is, um, is- is tempting to just fit a straight line to
[00:44:26] this data and then take the straight line and threshold it at 0.5, and then say, oh, if it's above 0.5 round off to 1,
[00:44:33] if it's below 0.5 round it off to 0. But it turns out that this, um, is not a good idea,
[00:44:40] uh, for classification problems. And- and here's why? Which is- for this data set it's really obvious what the- what the pattern is.
[00:44:47] Right? Everything to the left of this point predict 0. Everything to the right of that point predict 1. But let's say we now change the data set to just add one more example there.
[00:44:57] Right. And the pattern is still really obvious. It says everything to the left of this predict 0, everything to the right of that predict 1.
[00:45:03] But if you fit a straight line to this data set with this extra one point there, and just not even the outlier it's really
[00:45:09] obvious at this point way out there should be labeled one. But with this extra example, um,
[00:45:14] if we fit a straight line to the data, you end up with maybe something like that.
[00:45:19] Um, and somehow adding this one example, it really didn't change anything, right?
[00:45:25] But somehow the straight line fit moved from the green line to the, uh, moved from the blue line to the green line.
[00:45:30] And if you now threshold it at 0.5, you end up with a very different decision boundary.
[00:45:36] And so linear regression is just not a good algorithm for classification. Some people use it and sometimes they get lucky and it's not too bad but
[00:45:43] I- I- I personally never use linear regression for classification algorithms. Right. Because you just don't know if you end up with
[00:45:50] a really bad fit to the data like this, okay? Um, so oh and- and- and the other unnatural thing
[00:46:00] about using linear regression for a classification problem is that, um, you know for a classification problem that the values are,
[00:46:08] you know, 0 or 1. Right. And so it outputs negative values or values even
[00:46:13] greater than 1 seems- seems strange, um. So what I'd like to share with you now is really,
[00:46:23] probably by far the most commonly used classification algorithm ah, called logistic regression.
[00:46:29] Now let's say the two learning algorithms
[00:46:35] I probably use the most often are linear regression and logistic regression. Yeah, probably these two, actually. Um, and, uh, this is the algorithm.
[00:46:46] So, um, as- as we designed a logistic regression algorithm, one of the things we might naturally want is for
[00:46:54] the hypothesis to output values between 0 and 1. Right. And this is mathematical notation for the values for H of X or H prime,
[00:47:04] H subscript theta of X, uh, lies in the set from 0 to 1. Right? This 0 to 1 square bracket is the set of all real numbers from 0 to 1.
[00:47:13] So this says, we want the hypothesis output values in you know between 0 and 1, so that in the set of all numbers between z- from 0 to 1.
[00:47:20] Um, and so we're going to choose the following form of the hypothesis.
[00:47:26] Um, so. Okay. So we're gonna define a function,
[00:47:43] g of z, that looks like this. And this is called the sigmoid, uh,
[00:47:52] or the logistic function.
[00:47:58] Uh, these are synonyms, they mean exactly the same thing. So, uh, it can be called the sigmoid function,
[00:48:03] or the logistic function, it means exactly the same thing. But we're gonna choose a function, g of z.
[00:48:09] Uh, and this function is shaped as follows. If you plot this function, you find that it looks like this.
[00:48:16] Um, where if the horizontal axis is z, then this is g of z.
[00:48:22] And so it crosses x intercept at 0, um, and it, you know,
[00:48:28] starts off, well, really, really close to 0, rises, and then asymptotes towards 1.
[00:48:36] Okay? And so g of z output values are between 0 and 1. And, um, what logistic regression does is instead of- let's see.
[00:48:47] So previously, for linear regression, we had chosen this form for the hypothesis, right?
[00:48:52] We just made a choice that we'll say the housing prices are a linear function of the features x. And what logistic regression does is theta transpose x could be bigger than 1,
[00:49:02] it can be less than 0, which is not very natural. But instead, it's going to take theta transpose x and pass it
[00:49:07] through this sigmoid function g. So this force, the output values only between 0 and 1.
[00:49:14] Okay? Um, so you know,
[00:49:19] when designing a learning algorithm, uh, sometimes you just have to choose the form of the hypothesis.
[00:49:25] How are you gonna represent the function h, or h of- h subscript theta. And so we're making that choice here today.
[00:49:31] And if you're wondering, you know, there are lots of functions that we could have chosen, right?
[00:49:37] There are lots of why, why not, why not this function? Or why not, you know, there are lots of functions with vaguely this shape,
[00:49:43] they go between 0 and 1. So why are we choosing this specifically? It turns out that there's a broader class of algorithms called generalized linear models.
[00:49:52] You'll hear about on Wednesday, uh, of which this is a special case. So we've seen linear regression, you'll see logistic regression in a second, and on Wednesday,
[00:50:00] you'll see that both of these examples of a much bigger set of algorithms derived using a broader set of principles.
[00:50:05] So, so for now, just, you know, take my word for it tha- that we want to use the logistic function.
[00:50:10] Uh, uh, it'll turn out- you'll see on Wednesday that there's a way to derive even this function from, uh, from more basic principles,
[00:50:17] rather than just putting all this, this all out. But for now, let me just pull this out of a hat and say, that's the one we want to use.
[00:50:23] Okay. [NOISE]
[00:50:30] So, um, let's make some assumptions
[00:50:47] about the distribution of y given x parameterized by theta.
[00:50:52] So I'm going to assume that the data has the following distribution.
[00:50:59] The probability of y being 1, uh, again, from the breast cancer prediction that we had,
[00:51:04] from, uh, the first lecture. Right? It will be the chance of a tumor being cancerous,
[00:51:09] or being, um, um, malignant. Chance of y being 1, given the size of the tumor,
[00:51:14] that's the feature x parameterized by theta. That this is equal to the output of your hypothesis.
[00:51:24] So in other words, we're gonna assume that, um, what you want your learning algorithm to do is input
[00:51:29] the features and tell me what's the chance that this tumor is malignant. Right? What's the chance that y is equal to 1?
[00:51:36] Um, and by logic, I guess, because y can be only 1 or 0,
[00:51:43] the chance of y being equal to 0, this has got to be 1 minus that.
[00:51:50] Right? Because if a tumor has a 10% chance of being malignant, that means it has a 1 minus that.
[00:51:57] It means it must have a 90% chance of being benign. Right? Since these two probabilities must add up to 1. Okay? Yeah.
[00:52:03] [inaudible]
[00:52:14] Say that again. [inaudible]. Oh, can we change the parameters here? Yes, you can,
[00:52:20] but I'm not- yeah. But I think just to stick with convention in logistic regression. You, you- yeah.
[00:52:25] Sure. We can assume that p of y equals 1 was this, and p of y equals 1 was that, but I think either way. It's just one you call positive example,
[00:52:31] one you call a negative example. Right. So, so, uh, use this convention. Okay. Um, and now,
[00:52:39] bearing in mind that y, right? By definition, because it is a binary classification problem.
[00:52:46] But bear in mind that y can only take on two values, 0 or 1. Um, there's a nifty,
[00:52:52] sort of little algebra way to take these two equations and write them in one equation,
[00:52:58] and this will make some of the math a little bit easier. When I take these two equations, take these two assumptions and take these two facts,
[00:53:04] and compress it into one equation, which is this. [NOISE] [BACKGROUND] Okay?
[00:53:15] Oh, and I dropped the theta subscript just to simplify the notation of it. But I'm, I'm gonna be a little bit sloppy sometimes.
[00:53:21] Well, a little less formal, whether I write the theta there or not. Okay? Um, but these two definitions of p of y given x parameterized by theta,
[00:53:30] bearing in mind that y is either 0 or 1, can be compressed into one equation like this. Uh, and, and let me just say why.
[00:53:37] Right? It's because if y- use a different color.
[00:53:45] Right. If y is equal to 1,
[00:53:50] then this becomes h of x to the power of 1 times this thing to the power of 0.
[00:53:57] Right? If y is equal to 1, then, um, 1 - y is 0. And, you know, anything to the power of 0 is just equal to 1.
[00:54:08] [NOISE] And so if y is equal to 1, you end up with p of y given x parameterized by theta equals h of x.
[00:54:18] Right? Which is just what we had there.
[00:54:23] And conversely, if y is equal to 0,
[00:54:29] then, um, this thing will be 0, and this thing will be 1.
[00:54:34] And so you end up with p of y given x parameterized theta is equal to 1 minus h of x,
[00:54:40] which is just equal to that second equation. Okay? Right. Um, and so this is a nifty way
[00:54:50] to take these two equations and compress them into one line, because depending on whether y is 0 or 1,
[00:54:56] one of these two terms switches off, because it's exponentiated to the power of 0.
[00:55:01] Um, and anything to the power of 0 is just equal to 1. Right? So one of these terms is just, you know, 1.
[00:55:08] Just leaving the other term, and just selecting the, the appropriate equation, depending on whether y is 0 or 1.
[00:55:13] Okay? So with that, um, uh, so with this little, uh,
[00:55:19] on a notational trick, it will make the data derivations simpler.
[00:55:25] Okay? Um, yeah. So let me use a new board.
[00:55:42] [NOISE] I want that.
[00:55:53] All right. Actually we can reuse along with this.
[00:55:58] All right. So, uh, we're gonna use maximum likelihood estimation again. So let's write down the likelihood of the parameters.
[00:56:08] Um, so well, it's actually p of all the y's given all the x's parameterized by theta was equal to this, uh,
[00:56:17] which is now equal to product from i equals 1 through m, h of x_i to the power of y_i,
[00:56:25] times 1 minus h of x_i to the power of 1 minus y_i.
[00:56:32] Okay. Where all I did was take this definition of p of y given x parameterized by theta, uh, you know, from that,
[00:56:39] after we did that little exponentiation trick and wrote it in here. Okay. Um. [NOISE]
[00:56:50] And then, uh, with maximum likelihood estimation we'll want to find the value of theta that maximizes the likelihood,
[00:56:58] maximizes the likelihood of the parameters. And so, um, same as what we did for linear regression to make the algebra,
[00:57:07] you have to, to, to make the algebra a bit more simple, we're going to take the log of the likelihood and so compute the log likelihood.
[00:57:14] And so that's equal to, um, [NOISE] let's see, right.
[00:57:21] And so if you take the log of that, um, you end up with- you end up with that.
[00:57:45] Okay? And, um, it- so, so, in other words, uh,
[00:57:53] the last thing you want to do is, try to choose the value of theta to try to
[00:58:03] maximize L of theta. Okay. Now, so, so just,
[00:58:11] just to summarize where we are, right. Uh, if you're trying to predict, your malignancy and benign, uh,
[00:58:17] tumors, you'd have a training set with XI YI. You define the likelihood, define the log-likelihood.
[00:58:25] And then what you need to do is have an algorithm such as gradient descent, or gradient descent, talk about that in a sec to try to find the value of theta that maximizes the log-likelihood.
[00:58:35] And then having chosen the value of theta when a new patient walks into the doctor's office you would take the features of the new tumor
[00:58:43] and then use H of theta to estimate the chance of this new tumor in the new patient
[00:58:49] that walks in tomorrow to estimate the chance that this new thing is ah is- is malignant or benign.
[00:58:54] Okay? So the algorithm we're going to use to
[00:59:01] choose theta to try to maximize the log-likelihood is a gradient ascent or batch gradient ascent.
[00:59:09] And what that means is we will update the parameters theta J according to theta J
[00:59:16] plus the partial derivative with respect to the log-likelihood.
[00:59:25] Okay? Um, and the differences from what you saw that linear regression from last time is the following.
[00:59:33] Just two differences I guess. For linear regression. Last week, I have written this down,
[00:59:39] theta J gets updated as theta J minus partial with respect to theta J of J of theta, right?
[00:59:46] So you saw this on Wednesday. So the two differences between that is well, first instead of J of theta you're now
[00:59:55] trying to optimize the log-likelihood instead of this squared cost function. And the second change is, previously you were trying to minimize the squared error.
[01:00:03] That's why we had the minus. And today you're trying to maximize the log-likelihood which is why there's a plus sign.
[01:00:10] Okay? And so, um, so gradient descent you know,
[01:00:16] is trying to climb down this hill whereas gradient ascent has a,
[01:00:22] um, uh, has a- has a concave function like this. And it's trying to, like,
[01:00:28] climb up the hill rather than climb down the hill. So that's why there's a plus symbol here instead of
[01:00:34] a minus symbol because we are trying to maximize the function rather than minimize the function.
[01:00:40] So the last thing to really flesh out this algorithm which is done in the lecture notes,
[01:00:47] but I don't want to do it here today is to plug in the definition of H of theta into this equation and then take this thing.
[01:00:57] So that's the log-likelihood of theta and then through calculus and algebra you can take derivatives of this whole thing with respect to theta.
[01:01:07] This is done in detail in the lecture notes. I don't want to use this in class, but go ahead and take derivatives of this big formula with respect to
[01:01:14] the parameters theta in order to figure out what is that thing, right? What is this thing that I just circled?
[01:01:21] And it turns out that if you do so you will find that batch gradient ascent is the following.
[01:01:31] You update theta J according to- oh,
[01:01:41] actually I'm sorry, I forgot the learning rate. Yeah, it's your learning rate Alpha. Okay. Learning rate Alpha times this.
[01:01:53] Okay? Because this term here is the partial derivative respect to Theta J after log-likelihood.
[01:02:06] Okay? And the full calculus and so on derivations given the lecture notes.
[01:02:13] Okay? Um, yeah. [inaudible].
[01:02:18] Is there a chance of local maximum in this case? No. There isn't. It turns out that this function that the log-likelihood
[01:02:25] function L of Theta full logistic regression it always looks like that. Uh, so this is a concave function.
[01:02:31] So there are no local op. The only maximum is a global maxima. There's actually another reason why we chose the logistic function because if you
[01:02:38] choose a logistic function rather than some other function that will give you 0 to 1, you're guaranteed that the likelihood function has only one global maximum.
[01:02:46] And this, there's actually a big class about, actually what you'll see on Wednesday, this is a big class of algorithms of which linear regression is one example,
[01:02:55] logistic regression is another example and for all of the algorithms in this class there are no local optima problems when you- when you derive them this way.
[01:03:02] So you see that on Wednesday when we talk about generalized linear models. Okay? Um, so actually, but now that I think about,
[01:03:09] there's just one question for you to think about. This looks exactly the same as what we've figured out for linear regression, right?
[01:03:17] That when actually the difference for linear regression was I had a minus sign here and I reversed these two terms.
[01:03:22] I think I had H theta of XI minus YI. If you put the minus sign there and reverse these two terms,
[01:03:29] so take the minus minus, this is actually exactly the same as what we had come up with for linear regression.
[01:03:34] So why, why, why is this different, right? I started off saying, don't use linear regression for classification problems
[01:03:40] because of ah because of that problem that a single example could really you know- I started off with an example assuming that linear regression is
[01:03:47] really bad for classification and we did all this work and I came back to the same algorithm. So what happened? Just, yeah go ahead.
[01:03:55] [BACKGROUND]. Yeah. All right, cool. Awesome. Right? So what happened is
[01:04:01] the definition of H of theta is now different than before but the surface level of the equation turns out to be the same.
[01:04:09] Okay? And again it turns out that for every algorithm in this class of algorithms you'll see you on Wednesday you end up with the same thing.
[01:04:16] Actually this is a general property of a much bigger class of algorithms called generalized linear models.
[01:04:22] Although, yeah, i- i- interesting historical diverge, because of the confusion
[01:04:28] between these two algorithms in the early history of machine learning there was some debate about you know between academics saying,
[01:04:35] no, I invented that, no, I invented that. And then he goes, no, it's actually different algorithms.
[01:04:40] [LAUGHTER] Alright, any questions? Oh go ahead.
[01:04:47] [BACKGROUND].
[01:04:53] Oh, great question. Is there a equivalent of normal equations to logistic regression? Um, short answer is no.
[01:05:00] So for linear regression the normal equations gives you like a one shot way to just find the best value of theta.
[01:05:06] There is no known way to just have a close form equation unless you find the best value of theta which is why you always have to use an algorithm,
[01:05:13] an iterative optimization algorithm such as gradient ascent or ah and we'll see in a second Newton's method.
[01:05:21] All right, cool. So, um, there's a great lead in to, um,
[01:05:30] the last topic for today which is Newton's method.
[01:05:36] [NOISE]
[01:05:57] Um, you know, gradient ascent right is a good algorithm. I use gradient ascent all the time but it takes a baby step, takes a baby step,
[01:06:03] take a baby step, it takes a lot of iterations for gradient assent to converge. Um, there's another algorithm called Newton's method
[01:06:11] which allows you to take much bigger jumps so that's theta, you know, so- so, uh, there are problems where you might need you know,say
[01:06:18] 100 iterations or 1000 iterations of gradient ascent. That if you run this algorithm called Newton's method you might need
[01:06:25] only 10 iterations to get a very good value of theta. But each iteration will be more expensive.
[01:06:31] We'll talk about pros and cons in a second. But, um, let's see how- let's- let's describe this algorithm which is sometimes much
[01:06:38] faster for gradient than gradient ascent for optimizing the value of theta.
[01:06:44] Okay? So what we'd like to do is, uh, all right,
[01:06:50] so let me- let me use this simplified one-dimensional problem to describe Newton's method.
[01:07:02] So I'm going to solve a slightly different problem with Newton's method which is say you have some function f, right,
[01:07:11] and you want to find a theta such that f of theta is equal to 0.
[01:07:22] Okay? So this is a problem that Newton's method solves. And the way we're going to use this later is what you
[01:07:29] really want is to maximize L of theta,
[01:07:37] right, and well at the maximum the first derivative must be 0.
[01:07:43] So i.e. you want to value where the derivative L prime of theta is equal to 0, right?
[01:07:52] And L prime is the derivative of theta because this is where L prime is another notation for the first derivative of theta.
[01:07:59] So you want to maximize a function or minimize a function. What that really means is you want to find a point where the derivative is equal to 0.
[01:08:06] So the way we're going to use Newton's method is we're going to set F of theta equal to the derivative and then try to find the point where the derivative is equal to 0.
[01:08:15] Okay? But to explain Newton's method I'm gonna, you know, work on this other problem where you have a function F and you just
[01:08:22] want to find the value of theta where F of theta is equal to 0 and then- and we'll set F equal to L prime theta and that's how we'll we'll apply this to um, logistic regression.
[01:08:33] So, let me draw in pictures how this algorithm works.
[01:08:39] Uh. [NOISE] [BACKGROUND] All right.
[01:08:53] So let's say that's the function f, and, you know, to make this drawable on a whiteboard,
[01:08:59] I'm gonna assume theta is just a real number for now. So theta is just a single, you know, like a scalar, a real number.
[01:09:05] Um, so this is how Newton's method works.
[01:09:11] Um, oh, and the goal is to find this point. Right? The goal is to find the value of theta where f of theta is equal to 0.
[01:09:19] Okay? So let's say you start off, um, right.
[01:09:25] Let's say you start off at this point. Right? At the first iteration, you have randomly initialized data, and actually theta is zero or something.
[01:09:31] But let's say you start off at that point. This is how one iteration of Newton's method will work,
[01:09:38] which is- let me use a different color.
[01:09:43] Right. Start off with theta 0, that's just a first value consideration. What we're going to do is look at the function f,
[01:09:50] and then find a line that is just tangent to f. So take the derivative of f and
[01:09:55] find a line that is just tangent to f. So take that red line.
[01:10:01] It just touches the function f. And we're gonna use, if you will, use a straight line approximation to f,
[01:10:07] and solve for where f touches the horizontal axis. So we're gonna solve for the point where this straight line touches the horizontal axis.
[01:10:16] Okay? And then we're going to set this, and that's one iteration of Newton's method.
[01:10:21] So we're gonna move from this value to this value, right? And then in the second iteration of Newton's method,
[01:10:29] we're gonna look at this point. And again, you know, take a line that is just tangent to it,
[01:10:35] and then solve for where this touches the horizontal axis, and then that's after two iterations of Newton's method.
[01:10:44] Right. And then you repeat. Take this, sometimes you can overshoot a little bit, but that's okay.
[01:10:50] Right? And then that's, um, there's a cycle back to red. Let's take the three,
[01:10:56] then you take this, let's take the four. [NOISE] Excuse me.
[01:11:11] So you can tell that Newton's method is actually a pretty fast algorithm.
[01:11:17] Right? When in just one, two, three, four iterations, we've gotten really really close to the point where f of theta is equal to 0.
[01:11:28] So let's write out the math for how you do this.
[01:11:33] So um, let's see. I'm going to- so let me just write out the,
[01:11:39] the derive, um, you know, how you go from theta 0 to theta 1. So I'm going to use this horizontal distance.
[01:11:46] I'm gonna denote this as, uh, delta. This triangle is uppercase Greek alphabet delta.
[01:11:53] Right? This is lowercase delta, that's uppercase delta. Right? Uh, and then the height here,
[01:11:59] well that's just f of theta 0. Right? This is the height of- it's just f of theta 0.
[01:12:05] And so, um, let's see.
[01:12:12] Right. So, uh, what we'd like to do is solve for the value of delta,
[01:12:20] because one iteration of Newton's method is a set, you know, of theta 1 is set to theta 0 minus delta.
[01:12:29] Right? So how do you solve for delta? Well, from, uh, calculus we know that
[01:12:35] the slope of the function f is the height over the run. Well, height over the width.
[01:12:40] And so we know that the derivative of del- f prime, that's the derivative of f at the point theta 0,
[01:12:48] that's equal to the height, that's f of theta, divided by the horizontal. Right? So the derivative,
[01:12:56] meaning the slope of the red line is by definition the derivative is this ratio between this height over this width.
[01:13:03] Um, and so delta is equal to f of theta 0 over f prime of theta 0.
[01:13:13] And if you plug that in, then you find that a single iteration of Newton's method is
[01:13:19] the following rule of theta t plus 1 gets updated as
[01:13:25] theta t minus f of theta t over f prime of theta t. Okay.
[01:13:36] Where instead of 0 and 1 I replaced them with t and t plus 1.
[01:13:41] Right? Um, and finally to, to- you know,
[01:13:46] the very first thing we did was let's let f of theta be equal to say L prime of theta.
[01:13:55] Right? Because we wanna find the place where the first derivative of L is 0.
[01:14:00] Then this becomes theta t plus 1, gets updated as theta t minus L prime of
[01:14:08] theta t over L double prime of theta t. So it's really,
[01:14:16] uh, the first derivative divided by the second derivative. Okay?
[01:14:22] So Newton's method
[01:14:40] is a very fast algorithm, and, uh, it has, um,
[01:14:45] Newton's method enjoys a property called quadratic convergence.
[01:14:51] Not a great name. Don't worry- don't worry too much about what it means. But informally, what it means is that, um,
[01:14:57] if on one iteration Newton's method has 0.01 error,
[01:15:03] so on the X axis, you're 0.01 away from the, from the value, from the true minimum,
[01:15:08] or the true value of f is equal to 0. Um, after one iteration, the error could go to 0.0001 error,
[01:15:16] and after two iterations it goes 0.00000001.
[01:15:24] But roughly Newton's method, um, under certain assumptions, uh, uh,
[01:15:29] that functions move not too far from quadratic, the number of significant digits that you have
[01:15:35] converged, the minimum doubles on a single iteration. So this is called quadratic convergence. Um, and so when you get near the minimum,
[01:15:42] Newton's method converges extremely rapidly. Right? So, so after a single iteration, it becomes much more accurate,
[01:15:47] after another iteration it becomes way, way, way more accurate, which is why Newton's method requires relatively few iterations.
[01:15:54] Um, and, uh, let's see. I have written out Newton's method for when theta is a real number.
[01:16:03] Um, when theta is a vector, right?
[01:16:12] Then the generalization of the rule I wrote above is the following, theta t plus 1 gets updated as theta t plus H that,
[01:16:25] where H is the Hessian matrix.
[01:16:35] So these details are written in the lecture notes. Um, but to give you a sense,
[01:16:40] it- when theta is a vector, this is the vector of derivatives.
[01:16:46] All right, so I guess this R_n plus 1 dimensional. If theta is in R_n plus 1,
[01:16:54] then this derivative respect to theta of the log-likelihood becomes a vector of derivatives,
[01:17:00] and the Hessian matrix, this becomes a matrix as R_n plus 1 by n plus 1.
[01:17:08] So it becomes a squared matrix with the dimension equal to the parameter vector theta. And the Hessian matrix is defined as the matrix of partial derivatives.
[01:17:22] Right? So um, [NOISE] and so the disadvantage of Newton's method is that in high-dimensional problems,
[01:17:31] if theta is a vector, then each step of Newton's method is much more expensive,
[01:17:36] because, um, you're, you're either solving a linear system equations, or having to invert a pretty big matrix.
[01:17:42] So if theta is ten-dimensional, you know, this involves inverting a 10 by 10 matrix, which is fine.
[01:17:48] But if theta was 10,000 or 100,000, then each iteration requires computing like a
[01:17:54] 100,000 by a 100,000 matrix and inverting that, which is very hard. Right? It's actually very difficult to do that in very high-dimensional problems.
[01:18:02] Um, so, you know, some rules of thumb, um, if the number of parameters you have
[01:18:09] for- if the number of parameters in your iteration is not too big, if you have 10 parameters, or 50 parameters,
[01:18:14] I would almost certainly- I would very likely use Newton's method, uh, because then you probably get convergence in maybe 10 iterations,
[01:18:24] or, you know, 15 iterations, or even less than 10 iterations. But if you have a very large number of parameters,
[01:18:30] if you have, you know, 10,000 parameters, then rather than dealing with a 10,000 by 10,000 matrix, or even bigger,
[01:18:36] the 50 by 1000 by 50,000 matrix, and you have 50,000 parameters, I will use, uh, gradient descent then.
[01:18:43] Okay? But if the number of parameters is not too big, so that the computational cost per iteration is manageable,
[01:18:49] then Newton's method converges in a very small number of iterations, and, and could be much faster algorithm than gradient descent.
[01:18:56] All right. So, um, that's it for, uh, Newton's method.
[01:19:02] Um, on Wednesday, I guess we are running out of time. On Wednesday, you'll hear about generalized linear models.
[01:19:07] Um, I think unfortunately I- I promised to be in Washington DC, uh, uh, tonight, I guess through Wednesday.
[01:19:14] So, uh, you'll hear from some- I think Anand will give the lecture on Wednesday, uh, but I will be back next week.
[01:19:21] So un- unfortunately was trying to do this, but because of his health things, he can't lecture. So Anand will do this Wednesday.
[01:19:27] Thanks everyone. See you on Wednesday.