\documentclass[11pt]{article}
% Font & ngôn ngữ tiếng Việt (pdfLaTeX)
\usepackage[utf8]{inputenc}
\usepackage[T5]{fontenc}			


% Biblatex + biber
\usepackage[backend=biber, style=alphabetic, sorting=ynt]{biblatex}
\addbibresource{references.bib}
\usepackage{listings}
\usepackage{xcolor}
\lstdefinestyle{shell}{
	language=bash,
	basicstyle=\ttfamily\small,
	commentstyle=\color{green!60!black},
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	emphstyle=\color{purple},
	backgroundcolor=\color{gray!10},
	showstringspaces=false,
	frame=single,
	breaklines=true,
	emph={[1]\$\ },  % This is the key part: highlight the prompt
	emph=[1]{git, conda, mkdir, cd, pip} % Also emphasize key commands
}

% Toán học & font Times
\usepackage{amsmath, amssymb, amsfonts, bm}

% Bảng biểu & căn lề
\usepackage{longtable}
\usepackage{array}
\usepackage{booktabs}

% Đồ họa & màu sắc
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage{subcaption}

% Liên kết & tham chiếu
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=red,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
}
\usepackage{bookmark}

% Dấu tick và x
\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}
\newcommand{\cmark}{\ding{51}}

% Tiêu đề tùy chỉnh
\usepackage{titling}
\setlength{\droptitle}{-10em}
\renewcommand{\maketitle}{%
    \begin{center}
        \fontsize{18}{20}\selectfont\textbf{Data Version Control (DVC) \\[0.2em] in Machine Learning Projects}\\[1em]
        \fontsize{14}{16}\selectfont Nhóm MLOps\\[0.5em]
        \fontsize{14}{16}\selectfont Ngày 18 tháng 10 năm 2025
    \end{center}
    \vspace{1.5em}
}

% Format section (không đánh số)
\usepackage{titlesec}
\titleformat{\section}{\normalfont\Large\bfseries}{}{0em}{}

% Code block
\usepackage{listings}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstset{
    backgroundcolor=\color{backcolour},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b
}

% Hộp màu
\usepackage[many]{tcolorbox}
\definecolor{lightgreenbox}{rgb}{0.85,0.95,0.85}
\newtcolorbox{summarybox}{
    colback=lightgreenbox,
    colframe=green!50!black,
    boxsep=5pt, arc=4pt,
    boxrule=0.5pt,
    left=10pt, right=10pt,
    top=10pt, bottom=10pt,
}


% Layout trang
\setlength{\topmargin}{-0.7in}
\setlength{\textheight}{9.25in}
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.8in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

\begin{summarybox}
Nội dung về Data Version Control (DVC) được chia thành 5 phần chính:
    \begin{itemize}
        \item \textbf{Phần 1: Tổng quan về AI, MLOps và Data Versioning}
        \item \textbf{Phần 2: Thách thức trong Quản lý Dữ liệu và Code}
        \item \textbf{Phần 3: Giới thiệu về Data Version Control (DVC)}
        \item \textbf{Phần 4: Case Study: Triển khai DVC cho Dataset MNIST}
        \item \textbf{Phần 5: Tự động hóa Pipelines và Các khái niệm Versioning}
    \end{itemize}
\end{summarybox}

\section{Phần 1: Tổng quan về AI, MLOps và Phiên bản hóa Dữ liệu (Data Versioning)}

\subsection{Data Versioning là gì ?}
\textbf{Data Versioning} (phiên bản hóa dữ liệu) là một hệ thống dùng để quản lý và theo dõi những thay đổi của dữ liệu và mô hình trong suốt vòng đời dự án Machine Learning (ML). \\
T
Nó không chỉ lưu lại các phiên bản khác nhau của bộ dữ liệu (dataset), mà còn quản lý cả các file cấu hình (Config), tham số (parameters) và kết quả đánh giá (Eval result).
Về cơ bản, nó hoạt động như "Git cho dữ liệu", giúp kết nối một phiên bản code cụ thể với một phiên bản dữ liệu chính xác mà code đó đã sử dụng để huấn luyện và tạo ra mô hình.

\subsection{Vì sao cần Data Versioning?}

\subsubsection{Góc nhìn nghiệp vụ (Business Perspective)}
Từ góc nhìn nghiệp vụ, AI được xem là một chức năng (function) để giải quyết các bài toán cụ thể, ví dụ như phân tích cảm xúc (Sentiment Analysis) hay
xây dựng hệ thống gợi ý (Recommendation) trong một hệ thống phần mềm lớn như Thương mại điện tử.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/bs_pers.png}
    \caption{Vai trò của AI trong một hệ thống Thương mại điện tử}
\end{figure}

Toàn bộ quy trình ML bắt đầu từ \textbf{Yêu cầu Nghiệp vụ (Business Require)} và đi qua một vòng đời (life cycle) hoàn chỉnh. Để đảm bảo chất lượng (Quality Ensurement) và giám sát (Monitoring) mô hình AI một cách hiệu quả, doanh nghiệp phải có khả năng trả lời các câu hỏi:
\begin{itemize}
    \item Mô hình đang chạy trên production được huấn luyện từ dữ liệu nào?
    \item Khi mô hình dự đoán sai, làm thế nào để tái lập (reproduce) lỗi đó?
    \item Nếu dữ liệu mới làm giảm hiệu suất, làm sao để quay lại phiên bản mô hình ổn định trước đó?
\end{itemize}
Data versioning cung cấp khả năng \textbf{truy xuất nguồn gốc (lineage)} này, cho phép theo dõi chính xác code nào, dữ liệu nào, tham số nào đã tạo ra mô hình nào.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/cv_lifecycle.png}
    \caption{Vòng đời Machine Learning (ML Life Cycle)}
\end{figure}



\subsubsection{Góc nhìn MLOps}
MLOps tập trung vào việc tự động hóa và tinh gọn quy trình (pipeline) để chuyển giao mô hình từ môi trường nghiên cứu (Research Environment) sang môi trường triển khai (AI Service). Quy trình này bao gồm các bước lặp đi lặp lại như Xử lý dữ liệu (Data Handling), Huấn luyện mô hình (Model Training), và Đánh giá mô hình (Model Evaluation).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/mlop_pipeline.png}
    \caption{Quy trình MLOps cơ bản}
\end{figure}

Data versioning là thành phần quan trọng trả lời câu hỏi "Ở đâu và tại sao chúng ta cần phiên bản hóa dữ liệu ?". Nó giúp tự động hóa việc quản lý các "đầu ra" (artifacts) của mỗi bước (như dữ liệu đã xử lý, file mô hình, file chỉ số) và đảm bảo tính nhất quán giữa các môi trường, đặc biệt là khi làm việc nhóm.


\section{Phần 2: Thách thức trong Quản lý Dữ liệu và Code}
Khi thực nghiệm trên 1 tập dữ liệu lớn, các vấn đề như các thành viên trong nhóm "mất kết nối / ngừng hiểu" với dữ liệu, code, tham số và phiên bản mô hình là điều dễ thấy trong 1 nhóm. Nhất là đối với dữ liệu dạng TimeSeries vừa lớn mà vừa phải cập nhật liên tục. Để nhìn rõ hơn về vấn đề này, mình sẽ đi qua 2 ví dụ khi CÓ và KHÔNG CÓ data versioning pipeline.

\subsection{Ví dụ thực tế: Thử nghiệm mô hình Time Series}

\subsubsection{Khi KHÔNG có Data Versioning (Cách làm thủ công)}
Giả sử nhóm của bạn đang phát triển một mô hình dự báo chuỗi thời gian (time-series) phức tạp. Quy trình này tạo ra vô số file: `dataset files` (dữ liệu gốc), `parameters files` (tham số), `checkpoint files` (điểm kiểm tra mô hình), và `dataset augment files` (dữ liệu tăng cường).

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \includegraphics[width=\linewidth]{images/3problems.png}
        \caption{Vấn đề khi làm việc nhóm thủ công}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \includegraphics[width=\linewidth]{images/timeseries.png}
        \caption{Pipeline sinh ra nhiều phiên bản file}
    \end{subfigure}
    \caption{Sự hỗn loạn khi quản lý thủ công các file dữ liệu và thử nghiệm}
\end{figure}

Khi một thành viên trong nhóm ("My teammate") muốn chạy thử nghiệm mới, quy trình của họ rất thủ công và làm chậm quá trình phát triển:
\begin{enumerate}
    \item \textbf{Pull new code}: Tải code mới nhất từ GitHub.
    \item \textbf{Download new dataset/params}: Vì Github không cho lưu file lớn hơn 100mb, hóm truy cập Google Drive, tìm đúng file dữ liệu, file tham số mới nhất và tải về thủ công.
    \item \textbf{Import files}: Sao chép các file này vào đúng thư mục trong source code.
\end{enumerate}
Điều này dẫn đến 3 vấn đề lớn: (1) Có quá nhiều phiên bản file dữ liệu, tham số của các mô hình khác nhau. (2) Code và dữ liệu của mỗi người không được đồng bộ, và (3) Gây cản trở khi làm việc nhóm. Mọi người sẽ bối rối tự hỏi "file \texttt{cnn\_ettm1\_mix1\_mask025.pkl} này được huấn luyện từ dữ liệu, mô hình, thời điểm nào ?". \\

\noindent $\longrightarrow$ Cần 1 quy trình (pipeline) thống nhất để kiểm soát các phiên bản mô hình, dữ liệu và code để cả team có thể hoạt động 1 cách đồng bộ mà không phải thông báo, gọi Google Meet để trao đổi nhiều chỉ để xác nhận những vấn đề nhỏ nhặt có tính lặp lại được nêu trên.


\subsubsection{Khi CÓ Data Versioning (với DVC)}
Khi sử dụng một công cụ như DVC, quy trình trên được đơn giản hóa triệt để.
\begin{enumerate}
    \item \textbf{git pull}: Thành viên nhóm tải code mới. Lần này, code mới bao gồm các file \texttt{.dvc} (siêu dữ liệu) nhỏ nhẹ trỏ đến dữ liệu.
    \item \textbf{dvc pull}: Họ chỉ cần chạy lệnh này. DVC sẽ đọc các file \texttt{.dvc}, tự động tìm và tải về đúng phiên bản dữ liệu, tham số, và mô hình tương ứng với phiên bản code đó từ bộ lưu trữ (ví dụ: S3, Google Drive, hoặc SSH).
\end{enumerate}
Bằng cách này, DVC giải quyết vấn đề "disconnected" bằng cách liên kết code và dữ liệu một cách chặt chẽ thông qua các \texttt{commit}. Mọi thử nghiệm đều được ghi lại, nhất quán và có thể \textbf{tái lập (reproducible)} một cách chính xác bất cứ lúc nào.



\section{Phần 3: Giới thiệu về Data Version Control (DVC)}
DVC (Data Version Control) là một công cụ mã nguồn mở được thiết kế để quản lý dữ liệu và các dự án Machine Learning, hoạt động song song để bổ trợ cho Git \cite{dvc_org_website}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{images/vs_dvc.png} \\
    \caption{DvC đồng bộ bộ hóa code, dữ liệu, cấu hình và mô hình cho mỗi phiên bản, mỗi khi có sự thay đổi sau Huấn Luyện}
\end{figure}

\subsection{Workflow Quản lý Phiên bản Dữ liệu}
Một workflow phiên bản hóa dữ liệu (Data Versioning) là một vòng lặp quản lý liên tục. Quy trình này bắt đầu từ \textbf{Model Training} (Huấn luyện Mô hình), sử dụng một bộ \texttt{Data Config} (cấu hình dữ liệu) và \texttt{Model (params)} (tham số mô hình) cụ thể. Toàn bộ tài sản này (dữ liệu, tham số, kết quả đánh giá) được hệ thống \textbf{Data \& Model Management} theo dõi và lưu trữ. \\

Khi có dữ liệu mới (\texttt{New Data}) hoặc thay đổi cấu hình (\texttt{Diff Config}), quy trình \textbf{Continuos Training} (Huấn luyện Liên tục) sẽ được kích hoạt để tạo ra mô hình mới (\texttt{New Model}) và kết quả đánh giá mới (\texttt{New Eval result}). Phiên bản mới này lại tiếp tục được hệ thống quản lý, hoặc sẵn sàng cho việc \textbf{Model Deployment} (Triển khai).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/dv_managements.png}
    \caption{Workflow quản lý dữ liệu và mô hình trong MLOps}
\end{figure}

\subsection{So sánh DVC và Giới thiệu chi tiết}
Trên thị trường có nhiều công cụ để phiên bản hóa dữ liệu như Delta Lake, Pachyderm, và DVC. Tuy nhiên, DVC trở nên rất phổ biến vì các lý do chính:
\begin{itemize}
    \item \textbf{Mã nguồn mở}: Sử dụng giấy phép Apache 2.0.
    \item \textbf{Độc lập với định dạng}: \textbf{Data Format Agnostic}, nghĩa là nó có thể quản lý bất kỳ loại file nào (model, .csv, .parquet, hình ảnh...).
    \item \textbf{Độc lập với lưu trữ}: \textbf{Cloud/Storage Agnostic}, hỗ trợ hầu hết các nền tảng lưu trữ phổ biến như S3, GCP, Azure, SSH.
    \item \textbf{Dễ sử dụng}: \textbf{Simple to Use}, vì có các lệnh tương tự Git.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/dv_soft.png}
    \caption{So sánh các công cụ Data Version Control phổ biến}
\end{figure}

Về cơ bản, DVC là một nền tảng khoa học dữ liệu cho phép bạn liên kết \texttt{code}, \texttt{data} (dữ liệu), và \texttt{configuration} (cấu hình) để tạo ra các \texttt{model} (mô hình) có thể tái lập (reproducible).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/what_dvc.png}
    \caption{DVC liên kết Code, Data, và Configuration để quản lý Model}
\end{figure}

\subsubsection{DVC khác Git như thế nào?}
Điểm khác biệt cốt lõi là: \textbf{Git quản lý Code} (mã nguồn), trong khi \textbf{DVC quản lý Data} (dữ liệu). \\

\noindent Git không được thiết kế để xử lý các file lớn (ví dụ: mô hình 500MB). Khi bạn dùng DVC, quy trình làm việc (Local/Remote) sẽ được tách biệt rõ ràng:
\begin{itemize}
    \item \textbf{Git (Code)}: Bạn dùng \texttt{git push/pull} để đồng bộ code (ví dụ: \texttt{train.py}) và các file \texttt{.dvc} siêu dữ liệu (chỉ nặng vài KB) lên máy chủ Git (như GitHub, GitLab).
    \item \textbf{DVC (Data)}: Bạn dùng \texttt{dvc push/pull} để đồng bộ các file dữ liệu lớn thực tế (ví dụ: \texttt{model.pkl} 500MB) lên một máy chủ lưu trữ (Storage) riêng biệt (như S3, Azure, Google Cloud, SSH).
\end{itemize}




file \texttt{model.pkl.dvc} (1KB) mà Git theo dõi chỉ là một "con trỏ" (pointer) trỏ đến file \texttt{model.pkl} (500MB) thực sự được DVC quản lý. Điều này giữ cho kho Git của bạn luôn nhỏ gọn.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/git_v_dvc.png}
    \caption{DVC và Git hoạt động song song: Git quản lý Code, DVC quản lý Data}
\end{figure}

\pagebreak

\noindent DvC có độ tương đồng 1-1 so với Git về câu lệnh (ví dụ: \texttt{dvc add}, \texttt{dvc push}, \texttt{dvc pull}), giúp bất kì ai quen thuộc với version control của git hiểu ngay khi sử dụng.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/dvc_commands.png}
    \caption{DVC Cheat Sheet cho thấy sự tương đồng với các lệnh Git}
\end{figure}

\subsection{Quy trình DVC Pipeline hoàn chỉnh}
Một DVC pipeline hoàn chỉnh cho phép bạn tự động hóa toàn bộ quy trình ML và đảm bảo tính tái lập (reproducibility). Bộ não hay còn gọi là cấu hình (config) của pipeline là file \texttt{dvc.yaml}.

\subsubsection{Định nghĩa Pipeline (dvc.yaml)}
file \texttt{dvc.yaml} là nơi bạn định nghĩa tất cả các \textbf{stages} (giai đoạn) của quy trình ML. Mỗi stage giống như một bước trong "công thức" của bạn. Một stage thường bao gồm:
\begin{itemize}
    \item \texttt{cmd}: Lệnh thực thi (ví dụ: \texttt{python train.py}).
    \item \texttt{deps}: Các file phụ thuộc (dependencies) là đầu vào của stage, ví dụ như code (`train.py`) hoặc dữ liệu thô (`data/raw.csv`).
    \item \texttt{params}: Các tham số (parameters), thường được định nghĩa trong file \texttt{params.yaml} (ví dụ: learning rate, số epochs).
    \item \texttt{outs}: Các file đầu ra (outputs) mà stage này tạo ra, ví dụ như mô hình đã huấn luyện (\texttt{model.pkl}) hoặc dữ liệu đã xử lý.
\end{itemize}

\subsubsection{Thực thi Pipeline (dvc repro)}
Khi bạn chạy lệnh \texttt{dvc repro}, DVC sẽ thực hiện một việc rất thông minh:
Nó kiểm tra file \texttt{dvc.yaml} và so sánh \textbf{hash} (một chuỗi định danh duy nhất) của các file \texttt{deps} và \texttt{params} hiện tại với thông tin được lưu trong file \texttt{dvc.lock}.

\begin{itemize}
    \item file \texttt{dvc.lock} lưu lại "dấu vân tay" (hash) của các file \texttt{deps}, \texttt{params}, và \texttt{outs} từ lần chạy thành công trước đó.
    \item Nếu hash của bất kỳ file \texttt{deps} (ví dụ: bạn sửa code \texttt{train.py}) hoặc bất kỳ \texttt{params} nào thay đổi, DVC sẽ nhận ra stage đó là "lỗi thời" (outdated) và \textbf{chỉ chạy lại stage đó} cùng các stage phụ thuộc vào nó.
    \item Nếu không có gì thay đổi, DVC sẽ không chạy gì cả, giúp tiết kiệm thời gian tính toán.
\end{itemize}
Đây chính là cách DVC đảm bảo rằng mô hình của bạn luôn nhất quán với code và dữ liệu đã tạo ra nó.

\subsection{Các khái niệm DVC cốt lõi cần nhớ}
Đây là những ghi chú quan trọng và các khái niệm cần nhắc lại (từ các câu hỏi quiz buổi Thứ 5 Module 5 Week 1) trước khi đi vào thực hành.

\subsubsection{Quy trình làm việc chuẩn: DVC trước, Git sau}
Đây là quy tắc quan trọng nhất. Khi bạn có một file dữ liệu lớn (ví dụ: \texttt{data.zip}):
\begin{enumerate}
    \item \textbf{`dvc add data.zip`}: Lệnh này bảo DVC bắt đầu theo dõi \texttt{data.zip}. DVC sao chép file này vào kho lưu trữ cục bộ (\texttt{.dvc/cache}) và tạo ra một file siêu dữ liệu (pointer) nhỏ tên là \texttt{data.zip.dvc}.
    \item \textbf{`git add data.zip.dvc`}: Bạn dùng Git để theo dõi file pointer \texttt{.dvc} (chỉ vài KB), \textbf{KHÔNG BAO GIỜ} `git add` file \texttt{data.zip} gốc.
    \item \textbf{`git commit -m "Track new data"`}: Lưu lại trạng thái của file pointer.
\end{enumerate}
Nếu bạn `git add` file lớn trước, kho Git của bạn sẽ bị phình to và DVC sẽ không thể quản lý file đó.

\subsubsection{git push vs. dvc push}
Đây là điểm khác biệt cốt lõi (như trong hình \texttt{git\_v\_dvc.png}):
\begin{itemize}
    \item \textbf{`git push`}: Chỉ đẩy code (`.py`) và các file siêu dữ liệu/con trỏ (`.dvc`, `dvc.yaml`) lên máy chủ Git (như GitHub).
    \item \textbf{`dvc push`}: Đẩy các file dữ liệu lớn thực tế (mà DVC đang theo dõi) từ cache cục bộ (\texttt{.dvc/cache}) lên kho lưu trữ từ xa (Remote Storage) như AWS S3, GCS, hoặc SSH.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/git_v_dvc.png}
    \caption{Git quản lý Code/Metadata, DVC quản lý Data thực tế}
\end{figure}

\subsubsection{dvc pull vs. dvc checkout}
Khi làm việc nhóm, bạn sẽ dùng hai lệnh này:
\begin{itemize}
    \item \textbf{`dvc pull`}: Tải dữ liệu từ Remote Storage (ví dụ: S3) về kho lưu trữ cục bộ (Local Cache) của bạn (thư mục \texttt{.dvc/cache}).
    \item \textbf{`dvc checkout`}: Đồng bộ hóa dữ liệu từ Local Cache ra thư mục làm việc (workspace) của bạn. Lệnh này đọc các file \texttt{.dvc} trong workspace và tạo liên kết (symlink) đến các file tương ứng trong cache. Bạn thường chạy lệnh này sau khi \texttt{git checkout} một branch mới.
\end{itemize}

\subsubsection{Điều kiện tiên quyết cho DVC Pipeline}
Trước khi có thể chạy \texttt{dvc repro}, bạn cần đảm bảo:
\begin{enumerate}
    \item Dự án đã được khởi tạo là một kho Git (\texttt{git init}).
    \item Đã cài đặt các thư viện cần thiết (ví dụ: \texttt{pip install dvc dvc-s3}).
    \item Đã định nghĩa các stage trong file \texttt{dvc.yaml}.
    \item (Tùy chọn) Đã kết nối với kho lưu trữ AWS từ xa bằng lệnh \texttt{dvc remote add}, ví dụ: \\ \texttt{dvc remote add -d my-s3-storage s3://my-bucket/dvc-storage}. \href{https://tidy-legume-f9c.notion.site/H-ng-d-n-c-i-t-v-s-d-ng-AWS-S3-tr-n-CMD-Window-27f2acdfb48a80cb953eceeb97e30b0a}{Hướng dẫn setup AWS của TA trên Notion}
\end{enumerate}



\section{Phần 4: Case Study: Triển khai DVC cho Dataset MNIST}
Chúng ta sẽ thực hiện một case study từng bước để thấy DVC và Git hoạt động song song như thế nào để quản lý các phiên bản thử nghiệm (dữ liệu và mô hình).

\subsection{Bước 1: Thiết lập Dự án và Git}
Đầu tiên, chúng ta tạo thư mục dự án, cấu trúc thư mục con, môi trường \texttt{conda}, và quan trọng nhất là khởi tạo kho Git.

\begin{lstlisting}[language=bash]
$ # 1. Create project directory and basic structure
$ mkdir dvc-mnist-demo
$ cd dvc-mnist-demo
$ mkdir data/raw models scripts

$ # 2. Create conda environment and install libraries
$ conda create -n dvc_mnist python=3.11
$ conda activate dvc_mnist
$ pip install -r requirements.txt

$ # 3. Initialize Git and make the first commit
$ git init
$ git add .
$ git commit -m "Init project"
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{images/p3.png}
    \caption{Trạng thái Git và cấu trúc file ban đầu}
\end{figure}

\subsection{Bước 2: Tải Dataset V1 và Theo dõi bằng DVC}
Tiếp theo, chúng ta tải phiên bản đầu tiên của dataset (Full MNIST) và dùng DVC để bắt đầu theo dõi nó.

\begin{lstlisting}[language=bash]
$ # 1. Download data (60000 samples)
$ python scripts/download\_v1.py

$ # 2. Initialize DVC in the project
$ dvc init

$ # 3. Ask DVC to track the large data files
$ dvc add data/raw/x_train\_v1.npy data/raw/y_train\_v1.npy data/raw/x_test.npy data/raw/y_test.npy
\end{lstlisting}
Lệnh \texttt{dvc add} sẽ tạo ra các tệp \texttt{.dvc} (con trỏ) siêu dữ liệu và tự động thêm các tệp \texttt{.npy} lớn vào \texttt{.gitignore}.

\subsection{Bước 3: Commit Phiên bản Dữ liệu V1}
Giờ chúng ta commit các tệp \texttt{.dvc} (con trỏ) vào Git để lưu lại "phiên bản" dữ liệu này.

\begin{lstlisting}[language=bash]
$ # Add .dvc files (pointers) and the .gitignore file updated by DVC
$ git add data/raw/.gitignore data/raw/x_train\_v1.npy.dvc data/raw/y_train\_v1.npy.dvc data/raw/x_test.npy.dvc data/raw/y_test.npy.dvc

$ # Commit to finalize Version V1
$ git commit -m "Version 1: Full MNIST dataset"
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/p7.png}
    \caption{Lịch sử Git và DVC song song sau khi commit dữ liệu V1}
\end{figure}

\subsection{Bước 4: Huấn luyện và Theo dõi Mô hình V1}
Với dữ liệu V1, chúng ta huấn luyện mô hình đầu tiên và lại dùng DVC để theo dõi các tệp mô hình và chỉ số (metrics) đầu ra.

\begin{lstlisting}[language=bash]
$ # 1. (Optional) Create symbolic link for train.py script to read data
$ cd data/raw
$ mklink x_train.npy x_train\_v1.npy
$ mklink y_train.npy y_train\_v1.npy
$ cd ../..

$ # 2. Run training (on 60000 samples, achieved 0.9319 accuracy)
$ python scripts/train.py

$ # 3. Ask DVC to track output files (model and metrics)
$ dvc add models/model.npy
$ dvc add models/metrics.json

$ # 4. Commit V1 model's .dvc pointers to Git
$ git add .
$ git commit -m "Model v1: Full dataset accuracy"
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/p10.png}
    \caption{Toàn bộ lịch sử Git và DVC sau khi huấn luyện và commit Mô hình V1}
\end{figure}


\subsection{Bước 5: Tạo Phiên bản Dữ liệu V2}
Bây giờ, chúng ta giả lập một thử nghiệm mới bằng cách tạo phiên bản dữ liệu thứ hai (chỉ 1000 mẫu).

\begin{lstlisting}[language=bash]
$ # 1. Run download\_v2.py script to create V2 data
$ python scripts/download\_v2.py

$ # 2. Ask DVC to track the new V2 data files
$ dvc add data/raw/x_train\_v2.npy
$ dvc add data/raw/y_train\_v2.npy

$ # 3. Commit V2's .dvc pointers to Git
$ git add .
$ git commit -m "Dataset V2"
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/p14.png}
    \caption{Lịch sử Git và DVC sau khi thêm "Dataset V2"}
\end{figure}

\subsection{Bước 6: Huấn luyện Mô hình V2}
Chúng ta lặp lại quy trình huấn luyện, nhưng lần này sử dụng dữ liệu V2 (bằng cách thay đổi symbolic link) để tạo ra mô hình V2.

\begin{lstlisting}[language=bash]
$ # 1. Update symbolic link to point to V2 data
$ cd data/raw
$ del x_train.npy y_train.npy
$ mklink x_train.npy x_train\_v2.npy
$ mklink y_train.npy y_train\_v2.npy
$ cd ../..

$ # 2. Run training (on 1000 samples, achieved 0.8047 accuracy)
$ python scripts/train.py
\end{lstlisting}

\subsection{Bước 7: Theo dõi Mô hình V2}
Giờ chúng ta theo dõi các tệp mô hình và chỉ số V2 mới.

\begin{lstlisting}[language=bash]
$ # 1. Ask DVC to track V2 model and metrics files
$ dvc add models/model.npy
$ dvc add models/metrics.json

$ # 2. Commit V2 model's .dvc pointers
$ git add .
$ git commit -m "Model v2: Small dataset accuracy"
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/p18.png}
    \caption{Lịch sử Git/DVC hoàn chỉnh với 2 phiên bản dữ liệu và 2 phiên bản mô hình}
\end{figure}

\subsection{Bước 8: Cấu hình Kho lưu trữ (Storage)}
Các tệp dữ liệu lớn thực sự nằm trong cache (\texttt{.dvc/cache}). Để chia sẻ chúng, ta cần thiết lập một kho lưu trữ từ xa (remote storage).

\subsubsection{Sử dụng Local Storage (Lưu trữ Cục bộ)}
Đây là cách đơn giản để chia sẻ cache trong cùng một máy hoặc qua mạng nội bộ.
\begin{lstlisting}[language=bash]
$ # 1. Create a directory outside the project to act as "storage"
$ mkdir dvc_storage
$ # 2. Add it as the "localremote" (save configuration to .dvc/config)
$ dvc remote add -d localremote ./dvc_storage
$ # 3. Push data from cache (.dvc/cache) to localremote
$ dvc push
\end{lstlisting}

\subsubsection{Sử dụng Cloud Storage (ví dụ: AWS S3)}
Đây là cách làm phổ biến nhất khi làm việc nhóm.
\begin{lstlisting}[language=bash]
$ # 1. Install the S3 support library
$ pip install dvc-s3
$ # 2. Add the S3 bucket as the "mys3" remote
$ dvc remote add -d mys3 s3://dvc-mnist-demo-bucket/data
$ # 3. Push data from cache to S3 (the default remote)
$ dvc push
\end{lstlisting}

\subsection{Bước 9: Kiểm tra Chuyển đổi Phiên bản}
Đây là sức mạnh lớn nhất của DVC. Chúng ta có thể quay lại bất kỳ thử nghiệm nào trong quá khứ.
Ví dụ, để quay lại commit của Mô hình V1:
\begin{lstlisting}[language=bash]
$ # 1. Find the commit_id of V1 (e.g., "Model v1: Full dataset accuracy")
$ git log

$ # 2. Revert to the code state of that commit
$ git checkout <commit_id_cua_V1>

$ # 3. Ask DVC to sync the corresponding data/model for that commit
$ dvc checkout

$ # 4. Check (will see V1 shape is 60000)
$ python -c "import numpy as np; print('V1 Data shape:', np.load('data/raw/x_train.npy').shape)"
\end{lstlisting}
Nếu bạn \texttt{git checkout master} và \texttt{dvc checkout} một lần nữa, dữ liệu sẽ quay về V2 (1000 mẫu).

\subsection{Bước 10: Push và Clone (Làm việc nhóm)}
Quy trình làm việc nhóm điển hình:
\begin{lstlisting}[language=bash]
$ # --- Person A (Pushing the project) ---
$ # 1. Push code and .dvc pointers to GitHub
$ git remote add origin <your-repository>
$ git push origin master
$ # 2. Push the actual data to Cloud Storage
$ dvc push

$ # --- Person B (Cloning the project) ---
$ # 1. Clone code and .dvc pointers from GitHub
$ git clone <your-repository>
$ # 2. Connect to Cloud Storage
$ dvc remote add -d mys3 s3://dvc-mnist-demo-bucket/data
$ # 3. Pull the actual data from Cloud Storage to cache
$ dvc pull
\end{lstlisting}

\subsection{Bước 11: Tổng kết Thao tác DVC cơ bản}
Workflow trên minh họa các lệnh DVC cơ bản bạn sẽ sử dụng hàng ngày:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/p22.png}
    \caption{Các lệnh DVC workflow cơ bản}
\end{figure}

\begin{lstlisting}[
  language=bash,
  commentstyle=\color{gray},
  escapechar={}, % Set the escape character to be nothing
]
$ # Ask DVC to track a file. Note: Track data file
$ dvc add data/raw/file.npy

$ # Sync data from cache to working directory (when checking out Git). Note: Switch data versions
$ dvc checkout

$ # Push data (large files) from cache to remote storage (S3, GCS...). Note: Send to remote
$ dvc push

$ # Pull data (large files) from remote storage to cache. Note: Get from remote
$ dvc pull

$ # Check status of data files compared to Git commit. Note: Check changes
$ dvc status

$ # List files currently tracked by DVC in the project
$ dvc list .
\end{lstlisting}




\section{Phần 5: Tự động hóa Pipelines và Các khái niệm Versioning}
Một trong những tính năng mạnh mẽ nhất của DVC là khả năng tự động hóa toàn bộ quy trình Machine Learning (ML pipeline) thông qua các tệp cấu hình (Configure File). \\

Tệp cấu hình chính là \texttt{dvc.yaml}. Bạn có thể coi nó như một "bản công thức" hay một "bản kế hoạch chi tiết" cho dự án của bạn. Nó là một tệp văn bản đơn giản mà con người có thể đọc được, thường nằm ở thư mục gốc (root) của dự án. Tệp này định nghĩa tất cả các \textbf{stages} (giai đoạn) trong quy trình của bạn, ví dụ: "bước 1: tải dữ liệu", "bước 2: xử lý dữ liệu", "bước 3: huấn luyện mô hình". \\

Mục đích của nó là giải quyết vấn đề "phải chạy thủ công" (manual work) và đảm bảo \textbf{khả năng tái lập (reproducibility)}. Thay vì phải nhớ chạy 5 tệp Python theo đúng thứ tự, bạn chỉ cần định nghĩa chúng một lần trong \texttt{dvc.yaml}. Sau đó, DVC sẽ tự động biết phải chạy gì, theo thứ tự nào, và quan trọng nhất: chỉ chạy lại những bước bị ảnh hưởng khi code hoặc dữ liệu của bạn thay đổi, giúp tiết kiệm rất nhiều thời gian. \\

\subsection{DVC Automation Pipeline (Quy trình Tự động hóa DVC)}
Hãy xem cách tệp \texttt{dvc.yaml} định nghĩa một pipeline.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{images/auto1.png}
    \caption{Cấu hình các giai đoạn (stages) trong \texttt{dvc.yaml}}
\end{figure}

Trong tệp \texttt{dvc.yaml}, mọi thứ được tổ chức trong \texttt{stages}:
\begin{itemize}
    \item \textbf{`stages:`}: Khai báo bắt đầu danh sách các giai đoạn.
    \item \textbf{`download\_v1:`}: Đây là \textbf{tên} của một stage.
    \item \textbf{`cmd:`}: Lệnh (command) sẽ được thực thi khi chạy stage này (ví dụ: \texttt{python scripts/download\_v1.py}).
    \item \textbf{`deps:`}: Các tệp phụ thuộc (dependencies). DVC sẽ theo dõi các tệp này. Nếu tệp \texttt{scripts/download\_v1.py} thay đổi, DVC sẽ biết stage này "lỗi thời" và cần chạy lại.
    \item \textbf{`outs:`}: Các tệp đầu ra (outputs). Đây là kết quả của stage (ví dụ: \texttt{data/raw/x\_train\_v1.npy}). DVC sẽ tự động theo dõi (giống như \texttt{dvc add}) các tệp này.
\end{itemize}
Bạn có thể thấy các stage \texttt{train\_v1} và \texttt{train\_v2} phức tạp hơn, chúng phụ thuộc vào cả script (\texttt{train.py}) và dữ liệu đầu vào (ví dụ: \texttt{data/raw/x\_train\_v1.npy}). Điều này tạo ra một chuỗi liên kết, hay một \textbf{DAG (Directed Acyclic Graph)}, nơi DVC hiểu rằng phải chạy \texttt{download\_v1} trước rồi mới được chạy \texttt{train\_v1}.

\subsubsection{Sử dụng params.yaml để Tối ưu Pipeline}
Việc sao chép và dán các stage \texttt{train\_v1} và \texttt{train\_v2} (như trong hình trên) rất dễ gây lỗi. Một cách tốt hơn là sử dụng tệp \texttt{params.yaml} để lưu trữ các tham số (hyperparameters).

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{images/auto3.png}
    \caption{Kết hợp \texttt{dvc.yaml} (phải) và \texttt{params.yaml} (trái)}
\end{figure}

Thay vì định nghĩa hai stage riêng biệt, chúng ta sử dụng "templating" (tạo mẫu):
\begin{enumerate}
    \item \textbf{`params.yaml`}: Chúng ta định nghĩa một biến \texttt{data\_version: ["v1", "v2"]}.
    \item \textbf{`dvc.yaml`}: Chúng ta tạo một stage \texttt{train\_\${data\_version}} (tên stage động).
    \item \textbf{`foreach:`}: DVC sẽ lặp qua từng mục (item) trong \texttt{data\_version}.
    \item \textbf{`\${item}`}: Biến giữ chỗ này sẽ được thay thế bằng "v1" và "v2" khi chạy.
\end{enumerate}
Với cách này, bạn chỉ cần định nghĩa stage \texttt{train} một lần. Nếu sau này bạn muốn thêm "v3", bạn chỉ cần thêm "v3" vào tệp \texttt{params.yaml} mà không cần sửa \texttt{dvc.yaml}.

\subsection{Ý tưởng của Versioning (Phiên bản hóa)}
Khái niệm cốt lõi của DVC là mở rộng Git workflow (quy trình làm việc của Git) cho dữ liệu và các thử nghiệm (experiments). Cách hoạt động tương tự git, mỗi nhánh tương ứng với 1 hướng phát triển. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{images/versoning.png}
    \caption{So sánh Git Workflow (trái) và Data Workflow (phải)}
\end{figure}

\begin{itemize}
    \item \textbf{Git Workflow (Bên trái):} Trong phát triển phần mềm, khi muốn phát triển một tính năng mới (feature), bạn tạo một \textbf{nhánh (branch)} mới từ \texttt{master}, thêm code (các commit màu xanh), và khi hoàn thành, bạn gộp (merge) nó trở lại.
    
    \item \textbf{Data Workflow (Bên phải):} Chúng ta áp dụng ý tưởng tương tự cho các thử nghiệm ML.
    \begin{itemize}
        \item Nhánh \texttt{master} là mô hình chính (production model) của bạn.
        \item Khi bạn muốn thử một ý tưởng mới, ví dụ thay đổi tham số \texttt{mask\_rate}, bạn tạo một nhánh Git mới tên là \texttt{Change\_mask\_rate}.
        \item Trên nhánh này, bạn thay đổi tệp \texttt{params.yaml}, sau đó chạy \texttt{dvc repro}. DVC sẽ tạo ra mô hình và chỉ số mới, sau đó bạn \texttt{git commit} các thay đổi đó (ví dụ: \texttt{dvc.lock}).
        \item Tương tự, bạn có thể tạo nhánh \texttt{change\_mixup\_rate} hoặc nhánh \texttt{datasetb} để thử nghiệm dữ liệu mới.
    \end{itemize}
\end{itemize}
Bằng cách này, mỗi nhánh Git đại diện cho một thử nghiệm ML hoàn chỉnh và có thể tái lập. Bạn có thể dễ dàng chuyển đổi giữa các thử nghiệm (\texttt{git checkout}) và so sánh kết quả (\texttt{dvc metrics diff}) mà không làm lộn xộn nhánh \texttt{master} chính.


\printbibliography
\end{document}